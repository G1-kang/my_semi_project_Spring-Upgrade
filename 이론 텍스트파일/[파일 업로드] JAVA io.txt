※ java I/O :  java InputStream / OutputStream

# 들어가며
어떠한 프로그램이든 input와 output이 있습니다.
예를 들면
키보드가 입력이 input이고 화면에 출력이 output입니다.
GUI프로그램에서는 이벤트가 입력이고 이벤트의 따른 명령문의 결과가 출력입니다. 
이 처럼 프로그램에서 데이터가 흐르는 개념을 스트림 또는 io스트림이라고 합니다.
모든 데이터의 흐름은 i/o이지만 처리하는 방식은 각각에 차이가 있습니다. 
그렇기 때문에 모든 i/o에 맞는 코드를 작성하고 적용 습득하는데는 한계가 있습니다.
>>> java에서는 이러한 문제를 최상위 추상클래스 InputStream과 OutputStream를 상속받아서 해결하게 하였습니다.
	


@ 스트림

# 입출력 스트림(Stream)이란? 
컴퓨터 공학에서의 스트림은 연속적인 데이터의 흐름 혹은 데이터를 전송하는 소프트웨어 모듈을 의미합니다.
java에서 입력 스트림은 
키보드, 네트워크 등과 같은 입력장치와 연결되고 다른쪽에는 자바 프로그램이 연결되어,
입력 장치로부터  입력된 데이터가 프로그램으로 순서대로 흘러가게 됩니다.
java에서 출력 스트림은
자바 프로그램에서 출력되는 데이터를 LCD 스크린, 네트워크 장치, 프린터 등과 같은 출력 
장치로 순서대로 흘려보냅니다.
이러한 스트림을 통해 흘러가는 데이터의 기본 단위는 1바이트(8비트) 입니다.
프로그램은 입력 스트림으로 부터 받은 바이트들을 필요에 따라 문자로 바꾸어 인식하기도 하고 
4바이트를 조합하여 하나의 정수(int)로 인식하기도 합니다.


# 스트림의 특징
- 스트림은 단방향이다.
	입력 스트림은 데이터가 입력 장치에서 자바 프로그램으로 들어가는 이며,
	출력 스트림은 자바 프로그램에서 출력 장치로 데이터가 이동하는 방향이다.
- 스트림은 선입선출 구조이다.
	입력 스트림에서 먼저 들어온 데이터가 프로그램에서 먼저 전달되고,
	출력 스트림은 자바 프로그램에서 출력한 순서대로 출력장치에 보냅니다.




----------------------------------------------------------------------------------------------------------------------------------------------------------






@ JAVA에서 입력 출력 스트림을 구현한 최상위 i/o 클래스

# 특징
- 자바는 기본적으로 바이트를 최소단위로 한 스트림을 사용합니다.
- 자바에서 스트림은 크게 바이트 스트림과 문자 스트림의 2종류로 나누어져 있다.
- 바이트 스트림을 구현한 최상위 추상클래스 InputStream과 OutputStream이 있습니다.
	(클래스는 뒤에 Stream이 있으면 바이트 스트림을 처리하기 위한 클래스입니다. )
- 문자 스트림을 구현한 최상위 추상클래스 Reader과 Writer가 있습니다. 
	(클래스 뒤에 Reader, Writer가 있으면 문자 스트림을 처리하는 클래스입니다.)


# i/o를 구현한 최상위 추상클래스(InputStream/OutputStream  vs  Reader/Writer)

1. 바이트 스트림 InputStream/OutputStream 
	: 바이트 스트림은 입출력되는 바이트의 바이너리값을 있는 그대로 처리하므로
 	  스트림에서 들어오는 데이터가 문자이든 단순 바이너리 정보이든 상관없이 처리합니다.

-  abstract class InputStream
	InputStream은 read()메서드를 abstract 메서드로 지정하여 상속받는 
	클래스들이 필수적으로 구현하게 하였습니다.
	read(byte b)메서드는 기본적으로 1바이트의 데이터를 읽게 할 수 있습니다.
	하지만 한 번 작업시 1바이트의 데이터를 읽는것은 너무나 느리기 때문에
	바이트 배열을 인자로 받아서(read(byte[] buf)) 한번에 읽어오는 데이터 크기를 지정할 수도 있습니다.  
-  abstract class OutputStream
	OutputStream은 write()메서드를 abstract 메서드로 지정하여 상속받는
	클래스에서 필수적으로 구현하게 하였습니다.
	write(byte[ ] b) OutputStream생성시 사용된 인자(파일)에 
	바이트 배열의 크기의(0~b.length()) 모든 바이트를 내보냅니다(작성)


2. 문자 스트림 Reader/Writer
 	: 문자 스트림은 들어오는 데이터가 문자여야 처리가 가능합니다.
- abstract class Reader
	//향후 보충 예정
- abstract class Writer
	//향후 보충 예정

# 간단한 스트림 연결 코드
==================================================================
1	InputStreamReader rd = new InputStreamReader(System.in);
2	int c = rd.read();
3	System.out.println(c);
==================================================================
코드설명 :	위의 코드는 System.in(키보드와 연결된 입력)에 의해 키보드로 입력된 문자가 바이너리 데이터로 입력됩니다.
	이후 문자를 다루는 InputStreamReader의 .read()메서트를 통해 읽습니다. 
	이후 문자 출력 스트림을 사용해 구현된 System.out.println()를 통해 출력 됩니다.

실행 결과 :    'A'입력 >>> '65' 출력
	콘솔에 입력커서가 뜨고 입력하면 입력된 문자가 바이너리 데이터로 입력됩니다.
 	이후 바이너리 데이터를 .read()메서드가 ASCII 코드(정수)로 읽습니다.
	읽은 정수 데이터를 int형 변수 c에 담고 c를 출력합니다. 




----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------




@  파일 입출력 스트림(FileInputStream/FileOutputStream)
	: 파일 입출력을 위한 클래스로서, 
	  파일로부터 바이너리 데이터를 읽거나 파일에 바이너리 데이터를 저장 가능합니다.

- InputStream을 상속한 class FileInputStream
	: FileInputStream 클래스는 파일에 연결한 바이트 스트림을 생성합니다.

# 간단한 FileInputStream 이용한 파일읽기 코드
==================================================================
1	FileInputStream fin = new FileInputStream("c:\\test.txt");	// 또는 File객체
2	int c;
3	while((c = fin.read()) != -1){ 	// .read() OR .read(new byte[n])
4	    System.out.print((char)c);
5	}
6	fin.close();
==================================================================
코드 설명 :	위의 FileInputStream은 생성시 인자로 파일이 있는 절대경로를 받거나, File객체를 받습니다.
	생성시 인자로 파일이 전달되면 해당 파일에 연결된 입력 바이트 스트림이 생성됩니다.
	fin.read()메서드는 파일을 1byte(영어 한글자)씩 읽어옵니다.
	read()메서드는 파일을 모두 읽었을때 -1을 리턴하여 파일을 모두 읽었음을 알려줍니다.
	fin.close()를 사용해 파일과 연결된 스트림을 닫습니다.
	
	즉, 위의 코드의 while문은 .read()메서드에서 FileInputStream과 연결된 파일의 바이트 데이터를 모두 읽었음을 알려주는 
	-1이 리턴되기 전까지 출력문에 의해 읽어온 1바이트의 문자를 char형으로 변환하여 출력합니다.
	그리고 파일을 전부 읽었다면 파일과 연결된 스트림을 꼭 닫아줍니다.
	
	*추가 fin.read() VS fin.read(new byte[n]) :
		fin.read()처럼 인자없이 기본으로 사용되면 연결된 파일을 읽어 올때 1byte(0~255)씩 읽어오게 됩니다.
		 (영어는 한 글자에 1byte라서 한번 읽을때 1글자 출력, 한글은 2byte이기 때문에 두번 읽어야 한 글자가 출력됩니다.)		
		fin.read(new byte[n])처럼 인자에 바이트 배열을 전달 할 경우 한번 읽을때 인자에 전달된 바이트 배열의 크기 만큼 읽습니다.

	*추가 int c를 사용하는 이유 :
	 	읽어온 1byte의 데이터를 받는 c의 타입이 int인 이유는 read() 메서드가 데이터를 모두 읽었음을 알려주는 리턴값 -1을 
	 	받아야 하기 때문에 0~255까지 표현가능한 byte타입이 아닌 음수를 표현가능하며 연산의 기본 타입인 int를 타입으로 사용합니다.




- OutputStream을 상속한 class FileInputStresm
	: 파일에 입력스트림을 통해 바이너리 데이터를 저장 가능합니다.

# 간단한 FileInputStresm이용한 파일쓰기 코드
==================================================================
1	FileOutputStream fout = new FileOutputStream("c:\\testOut.txt");
2	int num[]={49,50,51,52,53};	      // 1,2,3,4,5
3	byte b[]={65,66,67,68,69,70,13};	      // A,B,C,D,E,F,\n
4	for(int i=0; i<num.length; i++){
5	    fout.write(num[i]);      	// 파일에 num 배열의 원소를 바이트 정보로 기록한다.
6	    fout.write(58);	   	//  :
7	    fout.write(b);             	// 파일에 바이트 배열 b의 내용을 보두 그대로 기록한다.
8	}
9	fout.flush();
10	fout.close();
==================================================================
코드설명 :	위의 FileOutputStream은 생성시 인자로 파일이 있는 절대경로를 받거나, File객체를 받습니다.
	생성시 인자로 파일이 전달되면 해당 파일에 연결된 출력 바이트 스트림이 생성됩니다.
	fout.write()는 인자로 전달된 정수또는 바이트 배열을 바이트 정보로 기록합니다.
	fout.flush()로 출력스트림에 남아 있는(버퍼) 바이트 데이터를 출력합니다.
	fout.close()을 작성이 완료되면 통하여 파일과 연결된 스트림을 닫아줍니다.
	
	즉, FileOutputStream에 의해 작성할 파일을 전달하면 해당 파일에 출력스트림을 열게되며
	write()메서드에 의해 인자로 전달되는 정수를 바이트 문자로 작성합니다.(위의 예시는 write()는 정수하나씩 읽기 때문에 버퍼가 따로 없을것입니다.)
	그리고 flush()로 내부 buffer에 남아있는 데이터를 비우고 close를 이용해 연결된 스트림을 닫아줍니다.

	*추가  write(int b)  VS  write(byte[] b)   VS  write(byte[] b, int off, int len) :
		write(int b) : 입력된 정수를 그대로 작성.  
			ex) write(65)를 실행하면 해당 파일에 정수 65에 대응하는 아스키 코트 "A"가 작성됩니다.
		write(byte[] b) 바이트 배열 b에 저장된 모든 양수를 작성.
			ex) write(new byte[]{65,66,67,68,69,70,13})을 실행하면 
			      해당 파일에 배열안의 원소에 대응하는 아스키 코드 "ABCDEF/n"가 작성 됩니다.		
		write(byte[] b, int off, int len) 바이트 배열에 off번지 부터 len번지 까지에 저장된 양수를 작성합니다.	

	*추가 flush() 정의 :
		일반 : flush()는 출력 스트림과 버퍼된 출력 바이트를 강제로 쓰게 한다.
		네트워크 :flush()는 현재 버퍼에 저장되어 있는 내용을 클라이언트로 전송하고 버퍼를 비운다.

	*추가 내가 생각한 flush() 설명 :
		파일을 읽을때 2차 스트림인 BufferedInputStream등을 통해 buffer를 생성합니다.
		buffer를 다 내보내기 전에 프로그램을 종료하면 buffer에 들어있는 내용은 파일에 쓰여지지 않습니다.
		혹은 마지막에 남은 데이터가 버퍼를 채위지 못한다면 내용은 파일에 쓰여지지 않습니다.
		그 때 flush()를 호출하면 buffer의 내용이 파일에 쓰여집니다. 
		즉, flush()는 출력 스트림에 남아있는 데이터를 출력해줍니다.

	*추가 write()에 1byte를 넘는 정수를 전달한다면? :
		??? 모르겠음 write(-1)은 앞의 문자를 지우고 공백, write(-5)는 ?(아스키코드 63)이 나온다.


# 위의 코드를 실행해 작성된 testOut.txt 파일의 내용
=================
1:ABCDEF
2:ABCDEF
3:ABCDEF
4:ABCDEF
5:ABCDEF
=================




----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------




@ java.io VS java.nio 
	: 자바 4부터 새로운 입출력(New Input Output)이라는 뜻에서 java.nio 패키지에 포함되었는데
	  자바 7로 버전업하면서 자바 IO 와 NIO 사이의 일관성 없는 클래스 설계를 바로 잡고 비동기 채널 등의
	  네트워크 지원을 대폭 강화한 NIO.2 API가 추가 되었습니다.

# IO 와 NIO의 차이점
구분		io	nio
-----------------------------------------------------------
입출력 방식		스트림	채널
버퍼 방식		넌버퍼	버퍼
비동기 방식		지원x	지원o
블로킹/넌블록킹	블로킹만	블로킹/넌블로킹 


# 스트림 과 채널 : 
	*IO는 스트림(단방향) 기반입니다. 스트림은 입력 스트림과 출력 스트림이 구분되어 있습니다.
	데이터를 읽기 위해 입력 스트림을 생성, 데이터 출력 위해 출력 스트림 생성 해야합니다.
	
	*NIO 는 채널(양방향) 기반입니다. 채널은 스트림과는 다르게 양방향 입출력 가능합니다.
	그래서 입력과 출력을 위한 별도의 채널을 만들 필요 없습니다.

# 넌버퍼와 버퍼 :

- IO는 버퍼를 사용하지 않습니다.	
	IO 에서는 출력 스트림이 1바이트를 쓰면 입력 스트림이 1바이트를 읽습니다. 때문에 이런 시스템은 대체로 느립니다. 
	그래서 io는 버퍼를 제공해주는 보조 스트림인 BufferedInputStream/BufferedOutputStream을 
	2차 스트림으로 사용하여 버퍼를 사용하기도 합니다.	
	또한 io는 스트림에서 읽은 데이터를 즉시 처리하므로 스트림으로부터 입력된 전체 데이터를 별도로 저장하지 않으면 
	입력된 데이터의 위치를 이동해 가며 자유롭게 이용할 수 없습니다.
- NIO는 버퍼를 사용합니다.
	NIO는 기본적으로 버퍼를 사용하여 입출력을 합니다. 그래서 io보다 성능이 좋습니다.
	nio의 채널은 버퍼에 저장된 데이터를 출력하고 입력된 데이터를 버퍼에 저장합니다.
	nio는 읽은 데이터를 무조건 버퍼에 저장하며, 그렇기 때문에 데이터의 위치를 이동해 가며
	필요한 부분에서만 읽고 쓸수 있습니다.

# 블로킹과 넌블로킹
- IO는 쓰래드가 블로킹(대기상태)됩니다. 
	입력 스트림의 read()를 호출하면 데이터가 모두 입력되기 전까지 스레드는 블로킹 됩니다. 
	또한 출력 스트림의 write()를 호출하면 데이터가 모두 출력 전까지 스레드는 블로킹 됩니다.
	io스레드가 블로킹되면 다른 일을 할 수 없고 블로킹을 빠져나오기 위해 인터럽트할 수도 없습니다.
	블로킹에서 나오는 유일한 방법은 스트림을 닫는것 입니다.

- NIO는 블로킹과 넌블로킹 특징을 모두 가지고 있습니다.
	nio의 블로킹은 스레드를 인터럽트(작동중인 쓰레드를 안전하게 제어함)함으로써 빠져나올 수 있습니다.
	nio의 넌블로킹은 입출력 작업 시 스레드가 블로킹되지 않는 것을 말합니다.
	넌블로킹 되는 이유는 입출력 작업 준비가 완료된 채널만 선택해서 작업 스레드가 처리하므로 
	작업 스레드가 블로킹되지 않습니다.
	넌블로킹의 핵심 객체(기술)는 멀티플렉서인 셀렉터(Selector)이며, 셀렉터는 복수 개의 채널 중에서 
	준비완료된 채널을 선택하는 방법을 제공합니다.


# IO 와 NIO의 중에 어떤것을 선택해야 하는가?
	NIO는 불특정 다수의 클라이언트 연결 or 멀티 파일들을 넌블로킹이나 비동기 처리할 수 있습니다.
	이는 과도한 스레드 생성을 피하고 스래드를 효과적으로 재사용한다는 장점을 가집니다.
   	또한 운영체제의 버퍼를 이용한 입출력이 가능하므로 입출력 성능 향상됩니다.
	NIO는 연결 클라이언트 수가 많고 하나의 입출력 처리 작업이 오래걸리지 않는 경우에 사용하는 것이 좋습니다. 
	대용량의 데이터를 처리할때는 스레드에서 입출력 처리가 오래 걸리게 되므로 대기하는 작업의 수가 늘어납니다. 
	이때는 제한된 스레드로 처리하는 것이 불편할 수 있습니다.
	그렇기 때문데 데용량의 데이터 처리의 경우 IO가 더 효율적입니다. 
	NIO는 버퍼 할당 크기가 문제가 되고, 모든 입출력 작업에 버퍼를 무조건 사용해야 하므로 즉시 처리하는 IO보다 조금 더 복잡합니다.
	연결 클라이언트 수가 적고 전송되는 데이터가 대용량이면서 순차적으로 처리될 필요성이 있는 경우 IO로 서버를 구현하는 것이 좋습니다.

	결론 : 사용자가 많고 입출력 처리할 데이터가 크지 않다면 NIO
	         사용자가 적고 입출력 처리할 데이터카 크다면 IO를 사용합니다.




----------------------------------------------------------------------------------------------------------------------------------------------------------




@ 자바에 스트림을 구현한 클래스들 
- 참고 : https://hyeonstorage.tistory.com/250 

# I/O 클래스의 이름과 의미
	Stream으로 끝나는 클래스 : 바이트 단위로 입출력을 수행하는 클래스
	Reader / Writer로 끝나는 클래스 : 캐릭터 단위로 입출력을 수행하는 클래스
	File로 시작하는 클래스 : 하드디스크의 파일을 사용하는 클래스
	Data로 시작하는 클래스 : 자바의 원시 자료형을 출력하기 위한 클래스
	Buffered로 시작하는 클래스 : 시스템의 버퍼를 사용하는 클래스

	1차 스트림 : 입/출력 통로를 직접 만드는 클래스
	2차 스트림 : 기존의 통로를 이용하여 새로운 기능을 더하는 클래스

# 추상클래스 InputStream / OutputStream를 상속받았으면 바이트 단위로 읽는다.

# 추상클래스 Reader / Write를 상속받았으면 문자를 입출력 한다.





----------------------------------------------------------------------------------------------------------------------------------------------------------


@ 파일 입출력을 통한 파일복사 간단한 코드(해보세요)

========================================================================================
1	File f = new File("C:\\test.txt");		
2	FileInputStream fin = new FileInputStream(f);			// 입력스트림 생성
3	FileOutputStream fout = new FileOutputStream("C:\\testOut.txt");   	// 출력스트림 생성	
4	int c;
5	while((c = fin.read()) != -1){					// 1바이트씩 읽기 > 다 읽었으면 -1 리턴함
6	    System.out.print((char)c);	// 콘솔에 찍어보기(영어만 알아보게 나옴)
7	    fout.write(c);						// 1바이트씩 쓰기
8	}
9	bin.close();
10	bout.close();
========================================================================================
		

